1. RLP源码解析

   1. 概念：RLP(Recursive Length Prefix-- 递归长度前缀编码)：是一种编码算法

   2. 功能：主要用于编码任意嵌套结构的二进制数据，是以太坊中序列化和反序列化的主要方法，所有的区块、交易等数据结构都会经过RLP编码之后再存储到区块链数据库中

   3. 数据处理特性：

      1. RLP处理两类数据
         1. 字符串（一串二进制数据）
         2. 列表（不单是一个列表，可以是一个嵌套递归的结构，里面还可以包含字符串、列表

   4. RLP编码规则

      1. 对单个字节，如果其范围是在[0, 127]=[0x00,0x7f]中，它的RLP编码是其本身
      2. 如果不是单个字节，一个字符串的长度是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着字符串本身，这个前缀的值是128=0x80加上字符串的长度，由于被编码的字符串最大长度是55=0x37，因此单字节的前缀最大值0x80+0x37=0xb7，即编码的第一个字节取值范围是[0x80,0xb7]
      3. 如果字符串长度大于55个字节，它的RLP编码包含一个单字节的前缀，**然后后面跟着字符串的长度**，再后面跟着字符串本身，这个前缀的值是183=0xb7加上字符串的长度的二进制形式的字节长度
      4. 如果一个列表的总长度（列表总长度是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码包含一个单字节的前缀，后面跟着列表中各项元素的RLP编码，这个前缀的值是192=0xc0加上列表的总长度，编码的第一个字节的取值范围是[0xc0,0xf7]
      5. 如果一个列表的总长度大于55个字符，它的RLP编码包含一个单字节的前缀，后面跟着列表的总长度，再后面跟着列表中各项元素的RLP编码，这个前缀的值是0xf7加上**列表总长度二进制形式的字节长度**，编码的第一个字节取值范围是**[0xf8,0xff]**。

   5. 编码实例

      1. 规则1："d"="d"
      2. 规则2："dog"=[0x83,'d','o','g']
      3. 规则3：如果一个字符串长度1024，它的二进制就是10,0000,0000，该二进制长度为两个字节（一个字节8位），则该字符串前缀应该是0xb7+2=0xb9。字符串长度1024=0x400=0x04,0x00。编码的第一个字节范围是[0xb8,0xbf]
         1. [0xb9,0x04,0x00... ]
      4. 规则4：
         1. 空列表：[]=[0xc0]
         2. ["cat","dog"]=[0xc8,0x83,'c','a','t','0x83','d','o','g']
      5. 规则5：以列表总长度为1024为例，它的二进制就是1000000000，该二进制长度为两个字节（一个字节8位），则该字符串前缀应该是0xf9，列表总长度0x400，再跟上各项元素的总长度编码
         1. [...]=[0xf9,0x04,0x00,...]

   6. 解码规则

      1. 根据RLP解码规则和过程，RLP解码的输入一律视为二进制字符数组，其过程如下：

         1. 根据输入首字节数据，解码数据类型、实际数据长度和位置；
         2. 根据类型和实际数据，解码不同类型的数据；
         3. 继续解码剩余的数据；

         其中，解码数据类型、实际数据和位置的规则如下：

         1. 如果首字节（prefix）的值在[0,127]=[0x00 , 0x7f]范围之间，那么该数据时字符串，且字符串就是首字节本身；
         2. 如果首字节的值在[128,183]=[0x80,0xb7]范围之间，那么该数据是字符串，且字符串的长度等于首字节减去0x80，且字符串位于首字节之后，且字符串位于数据的长度之后；
         3. 如果首字节的值在[184,191]=[0xb8,0xbf]范围之间，那么该数据是字符串，且字符串的长度的字节长度等于首字节减去0xb7，数据的长度位于首字节之后，且字符串位于数据的长度之后；
         4. 如果首字节的值在[192,247]=[0xc0,0xf7]范围之间，那么该数据是列表，在这种情况下，需要对列表各项的数据进行递归解码。列表的总长度（列表各项编码后的长度之和）等于首字节减去0xc0，且列表各项位于首字节之后；
         5. 如果首字节的值在[248,255]=[0xf8,0xff]范围之间，那么该数据为列表，总长度大于55，列表的总长度的字节长度等于首字节减去0xf7，列表的总长度位于首字节之后，且列表各项位于列表的总长度之后；

   7. 总结

      1. RLP编码主要和字符串或者列表的长度有关，在解码的过程中，采用相对应编码规则逆推的方式进行
      2. 与其他的序列化方式相比，RLP编码优点在于灵活使用长度前缀来表示数据的实际长度，并且使用递归的方式可以编码相当大的数据
      3. 在接收到经过RLP编码的数据之后，根据第1个字节就可以推断出数据类型，长度，数据本身等信息。而其它的序列化方式，不能要搞第一个字节获得这么多信息
      
   8. 代码目录结构

   ```
   decode.go:解码器，把RLP数据解码成go的数据结构
   decode_tail_test.go/decode_test.go	解码器测试代码
   encode.go: 编码器，把go的数据结构转换成RLP编码
   encode_test.go/encode_example_test.go 编码器的测试
   raw.go 原始的RLP数据
   raw_test.go	测试文件
   typecache.go	类型缓存，记录了类型=>内容（编码器/解码器）
   ```

   9. typecache.go：根据给定的类型找到对应的编码器和解码器
      1. 在C++或者Java等语言中，支持重载，可以通过不同的类型重载同一个函数名称，来实现方法针对不同类型的实现，也可以通过泛型来实现函数的分派。

      2. ```
         string encode(int)
         string encode(log)
         string encode(struct test*)
         ```

      3. go语言本身不支持重载，也没有泛型，所有需要自己来实现函数的分派，typecache.go就是通过自身的类型快速找到对应的编码器与解码器的函数。

      4. 总结
         1. 该文件定义了类型=>编码器/解码器函数的核心数据结构
         2. 定义了编码器和解码器的函数
         3. 通过对应类型查找对应的编码器和解码器
         4. 通过给定的类型生成对应的编码器和解码器

   10. encoder.go：编码器函数，把数据结构转换为RLP编码

       1. 总结
           1. 定义编码器接口
           2. RLP编码函数
           3. RLP数据组装

   11. decoder.go：解码器函数，把RLP编码转换为对应的golang数据结构

        1. 总结
           1. 定义解码器接口
           2. RLP解析函数



